{"language":"Solidity","sources":{"src/SpritzPayCore.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\nimport {Ownable} from \"solady/auth/Ownable.sol\";\nimport {SafeTransferLib} from \"solady/utils/SafeTransferLib.sol\";\nimport {EnumerableSetLib} from \"solady/utils/EnumerableSetLib.sol\";\n\n/// @title SpritzPayCore\n/// @notice Core payment processing contract for Spritz Finance protocol\n/// @dev Handles token allowlisting, recipient management, and payment event emission.\n///      Designed to be called by SpritzRouter or directly for simple payments.\n///      Uses Solady for gas-efficient ownership and token transfers.\ncontract SpritzPayCore is Ownable {\n    using EnumerableSetLib for EnumerableSetLib.AddressSet;\n\n    /// @notice Thrown when attempting to pay with a token that is not accepted\n    /// @param token The token address that was rejected\n    error TokenNotAccepted(address token);\n\n    /// @notice Thrown when a zero address is provided where not allowed\n    error ZeroAddress();\n\n    /// @notice Emitted when a payment is successfully processed\n    /// @param to The recipient address that received the payment\n    /// @param from The address that initiated the payment\n    /// @param sourceToken The original token the payer used (may differ from paymentToken if swapped)\n    /// @param sourceTokenAmount The amount of source token spent by the payer\n    /// @param paymentToken The token that was actually transferred to the recipient\n    /// @param paymentTokenAmount The amount of payment token received by the recipient\n    /// @param paymentReference Unique identifier linking to an off-chain payment record\n    event Payment(\n        address to,\n        address indexed from,\n        address indexed sourceToken,\n        uint256 sourceTokenAmount,\n        address paymentToken,\n        uint256 paymentTokenAmount,\n        bytes32 indexed paymentReference\n    );\n\n    /// @dev Set of all accepted payment token addresses\n    EnumerableSetLib.AddressSet internal _acceptedPaymentTokens;\n\n    /// @notice Maps payment token addresses to their designated recipient addresses\n    mapping(address => address) public tokenRecipients;\n\n    /// @dev Constructor is payable to save gas on deployment\n    constructor() payable {}\n\n    /// @dev Enables the initializer pattern for Solady Ownable\n    function _guardInitializeOwner() internal pure override returns (bool) {\n        return true;\n    }\n\n    /// @notice Initializes the contract with an admin owner\n    /// @dev Can only be called once. Separate from constructor to support CREATE3 deployment.\n    /// @param admin Address that will own the contract and manage payment tokens\n    function initialize(address admin) external {\n        _initializeOwner(admin);\n    }\n\n    /// @notice Processes a payment by transferring tokens to the recipient and emitting an event\n    /// @dev Tokens must be transferred to this contract before calling pay().\n    ///      Typically called by SpritzRouter after handling approvals/swaps.\n    /// @param caller The original payer address (used for event emission)\n    /// @param paymentToken The token to transfer to the recipient (must be accepted)\n    /// @param paymentAmount Amount of paymentToken to transfer\n    /// @param sourceToken The token the payer originally used (for tracking, may equal paymentToken)\n    /// @param sourceTokenSpent Amount of sourceToken the payer spent\n    /// @param paymentReference Unique identifier for off-chain payment reconciliation\n    function pay(\n        address caller,\n        address paymentToken,\n        uint256 paymentAmount,\n        address sourceToken,\n        uint256 sourceTokenSpent,\n        bytes32 paymentReference\n    ) external {\n        address _paymentRecipient = tokenRecipients[paymentToken];\n        if (_paymentRecipient == address(0))\n            revert TokenNotAccepted(paymentToken);\n\n        emit Payment(\n            _paymentRecipient,\n            caller,\n            sourceToken,\n            sourceTokenSpent,\n            paymentToken,\n            paymentAmount,\n            paymentReference\n        );\n\n        SafeTransferLib.safeTransfer(\n            paymentToken,\n            _paymentRecipient,\n            paymentAmount\n        );\n    }\n\n    // ============ View Functions ============\n\n    /// @notice Returns all accepted payment token addresses\n    /// @return Array of token addresses that can be used for payments\n    function acceptedPaymentTokens() external view returns (address[] memory) {\n        return _acceptedPaymentTokens.values();\n    }\n\n    /// @notice Checks if a token is accepted for payments\n    /// @param tokenAddress The token address to check\n    /// @return True if the token is accepted, false otherwise\n    function isAcceptedToken(\n        address tokenAddress\n    ) external view returns (bool) {\n        return _acceptedPaymentTokens.contains(tokenAddress);\n    }\n\n    /// @notice Returns the recipient address for a payment token\n    /// @param tokenAddress The payment token address\n    /// @return The address that receives payments in this token (zero if not accepted)\n    function paymentRecipient(\n        address tokenAddress\n    ) external view returns (address) {\n        return tokenRecipients[tokenAddress];\n    }\n\n    // ============ Admin Functions ============\n\n    /// @notice Adds or updates an accepted payment token with its recipient\n    /// @dev Only callable by owner. Updates recipient if token already exists.\n    /// @param token The token address to accept\n    /// @param recipient The address that will receive payments in this token\n    function addPaymentToken(\n        address token,\n        address recipient\n    ) external onlyOwner {\n        if (token == address(0)) revert ZeroAddress();\n        if (recipient == address(0)) revert ZeroAddress();\n        _acceptedPaymentTokens.add(token);\n        tokenRecipients[token] = recipient;\n    }\n\n    /// @notice Removes a payment token from the accepted list\n    /// @dev Only callable by owner. Payments with this token will revert after removal.\n    /// @param token The token address to remove\n    function removePaymentToken(address token) external onlyOwner {\n        _acceptedPaymentTokens.remove(token);\n        delete tokenRecipients[token];\n    }\n\n    /// @notice Rescues tokens accidentally sent to this contract\n    /// @dev Only callable by owner. Transfers entire balance of specified token.\n    /// @param token The token to sweep\n    /// @param to The recipient address\n    function sweep(address token, address to) external onlyOwner {\n        uint256 balance = SafeTransferLib.balanceOf(token, address(this));\n        if (balance > 0) {\n            SafeTransferLib.safeTransfer(token, to, balance);\n        }\n    }\n}\n"},"lib/solady/src/auth/Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                           EVENTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STORAGE                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         MODIFIERS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"},"lib/solady/src/utils/SafeTransferLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\n/// @author Permit2 operations from (https://github.com/Uniswap/permit2/blob/main/src/libraries/Permit2Lib.sol)\n///\n/// @dev Note:\n/// - For ETH transfers, please use `forceSafeTransferETH` for DoS protection.\nlibrary SafeTransferLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The ETH transfer has failed.\n    error ETHTransferFailed();\n\n    /// @dev The ERC20 `transferFrom` has failed.\n    error TransferFromFailed();\n\n    /// @dev The ERC20 `transfer` has failed.\n    error TransferFailed();\n\n    /// @dev The ERC20 `approve` has failed.\n    error ApproveFailed();\n\n    /// @dev The ERC20 `totalSupply` query has failed.\n    error TotalSupplyQueryFailed();\n\n    /// @dev The Permit2 operation has failed.\n    error Permit2Failed();\n\n    /// @dev The Permit2 amount must be less than `2**160 - 1`.\n    error Permit2AmountOverflow();\n\n    /// @dev The Permit2 approve operation has failed.\n    error Permit2ApproveFailed();\n\n    /// @dev The Permit2 lockdown operation has failed.\n    error Permit2LockdownFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Suggested gas stipend for contract receiving ETH that disallows any storage writes.\n    uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;\n\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\n    /// storage reads and writes, but low enough to prevent griefing.\n    uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;\n\n    /// @dev The unique EIP-712 domain separator for the DAI token contract.\n    bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;\n\n    /// @dev The address for the WETH9 contract on Ethereum mainnet.\n    address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n    /// @dev The canonical Permit2 address.\n    /// [Github](https://github.com/Uniswap/permit2)\n    /// [Etherscan](https://etherscan.io/address/0x000000000022D473030F116dDEE9F6B43aC78BA3)\n    address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\n\n    /// @dev The canonical address of the `SELFDESTRUCT` ETH mover.\n    /// See: https://gist.github.com/Vectorized/1cb8ad4cf393b1378e08f23f79bd99fa\n    /// [Etherscan](https://etherscan.io/address/0x00000000000073c48c8055bD43D1A53799176f0D)\n    address internal constant ETH_MOVER = 0x00000000000073c48c8055bD43D1A53799176f0D;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       ETH OPERATIONS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // If the ETH transfer MUST succeed with a reasonable gas budget, use the force variants.\n    //\n    // The regular variants:\n    // - Forwards all remaining gas to the target.\n    // - Reverts if the target reverts.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The force variants:\n    // - Forwards with an optional gas stipend\n    //   (defaults to `GAS_STIPEND_NO_GRIEF`, which is sufficient for most cases).\n    // - If the target reverts, or if the gas stipend is exhausted,\n    //   creates a temporary contract to force send the ETH via `SELFDESTRUCT`.\n    //   Future compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758.\n    // - Reverts if the current contract has insufficient balance.\n    //\n    // The try variants:\n    // - Forwards with a mandatory gas stipend.\n    // - Instead of reverting, returns whether the transfer succeeded.\n\n    /// @dev Sends `amount` (in wei) ETH to `to`.\n    function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`.\n    function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) {\n                    revert(codesize(), codesize())\n                } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Force sends all the ETH in the current contract to `to`, with `GAS_STIPEND_NO_GRIEF`.\n    function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }\n\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Sends all the ETH in the current contract to `to`, with a `gasStipend`.\n    function trySafeTransferAllETH(address to, uint256 gasStipend) internal returns (bool success) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }\n\n    /// @dev Force transfers ETH to `to`, without triggering the fallback (if any).\n    /// This method attempts to use a separate contract to send via `SELFDESTRUCT`,\n    /// and upon failure, deploys a minimal vault to accrue the ETH.\n    function safeMoveETH(address to, uint256 amount) internal returns (address vault) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            to := shr(96, shl(96, to)) // Clean upper 96 bits.\n            for { let mover := ETH_MOVER } iszero(eq(to, address())) {} {\n                let selfBalanceBefore := selfbalance()\n                if or(lt(selfBalanceBefore, amount), eq(to, mover)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                if extcodesize(mover) {\n                    let balanceBefore := balance(to) // Check via delta, in case `SELFDESTRUCT` is bricked.\n                    mstore(0x00, to)\n                    pop(call(gas(), mover, amount, 0x00, 0x20, codesize(), 0x00))\n                    // If `address(to).balance >= amount + balanceBefore`, skip vault workflow.\n                    if iszero(lt(balance(to), add(amount, balanceBefore))) { break }\n                    // Just in case `SELFDESTRUCT` is changed to not revert and do nothing.\n                    if lt(selfBalanceBefore, selfbalance()) { invalid() }\n                }\n                let m := mload(0x40)\n                // If the mover is missing or bricked, deploy a minimal vault\n                // that withdraws all ETH to `to` when being called only by `to`.\n                // forgefmt: disable-next-item\n                mstore(add(m, 0x20), 0x33146025575b600160005260206000f35b3d3d3d3d47335af1601a5760003dfd)\n                mstore(m, or(to, shl(160, 0x6035600b3d3960353df3fe73)))\n                // Compute and store the bytecode hash.\n                mstore8(0x00, 0xff) // Write the prefix.\n                mstore(0x35, keccak256(m, 0x40))\n                mstore(0x01, shl(96, address())) // Deployer.\n                mstore(0x15, 0) // Salt.\n                vault := keccak256(0x00, 0x55)\n                pop(call(gas(), vault, amount, codesize(), 0x00, codesize(), 0x00))\n                // The vault returns a single word on success. Failure reverts with empty data.\n                if iszero(returndatasize()) {\n                    if iszero(create2(0, m, 0x40, 0)) { revert(codesize(), codesize()) } // For gas estimation.\n                }\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      ERC20 OPERATIONS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for\n    /// the current contract to manage.\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have their entire balance approved for the current contract to manage.\n    function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\n    /// Reverts upon failure.\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// Reverts upon failure.\n    function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\n    /// If the initial attempt to approve fails, attempts to reset the approved amount to zero,\n    /// then retries the approval again (some tokens, e.g. USDT, requires this).\n    /// Reverts upon failure.\n    function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }\n\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\n    /// Returns zero if the `token` does not exist.\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount := mul( // The arguments of `mul` are evaluated from right to left.\n                mload(0x20),\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                )\n            )\n        }\n    }\n\n    /// @dev Performs a `token.balanceOf(account)` check.\n    /// `implemented` denotes whether the `token` does not implement `balanceOf`.\n    /// `amount` is zero if the `token` does not implement `balanceOf`.\n    function checkBalanceOf(address token, address account)\n        internal\n        view\n        returns (bool implemented, uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            implemented := and( // The arguments of `and` are evaluated from right to left.\n                gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n            )\n            amount := mul(mload(0x20), implemented)\n        }\n    }\n\n    /// @dev Returns the total supply of the `token`.\n    /// Reverts if the token does not exist or does not implement `totalSupply()`.\n    function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\n    /// If the initial attempt fails, try to use Permit2 to transfer the token.\n    /// Reverts upon failure.\n    ///\n    /// The `from` account must have at least `amount` approved for the current contract to manage.\n    function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }\n\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to` via Permit2.\n    /// Reverts upon failure.\n    function permit2TransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }\n\n    /// @dev Permit a user to spend a given amount of\n    /// another user's tokens via native EIP-2612 permit if possible, falling\n    /// back to Permit2 if native permit fails or is not implemented on the token.\n    function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(\n                        add(m, 0x94),\n                        lt(iszero(amount), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    )\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `amount != 0` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Simple permit on the Permit2 contract.\n    function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n                mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))\n            ) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Approves `spender` to spend `amount` of `token` for `address(this)`.\n    function permit2Approve(address token, address spender, uint160 amount, uint48 expiration)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let addressMask := shr(96, not(0))\n            let m := mload(0x40)\n            mstore(m, 0x87517c45) // `approve(address,address,uint160,uint48)`.\n            mstore(add(m, 0x20), and(addressMask, token))\n            mstore(add(m, 0x40), and(addressMask, spender))\n            mstore(add(m, 0x60), and(addressMask, amount))\n            mstore(add(m, 0x80), and(0xffffffffffff, expiration))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x324f14ae) // `Permit2ApproveFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Revokes an approval for `token` and `spender` for `address(this)`.\n    function permit2Lockdown(address token, address spender) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0xcc53287f) // `Permit2.lockdown`.\n            mstore(add(m, 0x20), 0x20) // Offset of the `approvals`.\n            mstore(add(m, 0x40), 1) // `approvals.length`.\n            mstore(add(m, 0x60), shr(96, shl(96, token)))\n            mstore(add(m, 0x80), shr(96, shl(96, spender)))\n            if iszero(call(gas(), PERMIT2, 0, add(m, 0x1c), 0xa0, codesize(), 0x00)) {\n                mstore(0x00, 0x96b3de23) // `Permit2LockdownFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n}\n"},"lib/solady/src/utils/EnumerableSetLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for managing enumerable sets in storage.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/EnumerableSetLib.sol)\n///\n/// @dev Note:\n/// In many applications, the number of elements in an enumerable set is small.\n/// This enumerable set implementation avoids storing the length and indices\n/// for up to 3 elements. Once the length exceeds 3 for the first time, the length\n/// and indices will be initialized. The amortized cost of adding elements is O(1).\n///\n/// The AddressSet implementation packs the length with the 0th entry.\n///\n/// All enumerable sets except Uint8Set use a pop and swap mechanism to remove elements.\n/// This means that the iteration order of elements can change between element removals.\nlibrary EnumerableSetLib {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The index must be less than the length.\n    error IndexOutOfBounds();\n\n    /// @dev The value cannot be the zero sentinel.\n    error ValueIsZeroSentinel();\n\n    /// @dev Cannot accommodate a new unique value with the capacity.\n    error ExceedsCapacity();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The index to represent a value that does not exist.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /// @dev A sentinel value to denote the zero value in storage.\n    /// No elements can be equal to this value.\n    /// `uint72(bytes9(keccak256(bytes(\"_ZERO_SENTINEL\"))))`.\n    uint256 private constant _ZERO_SENTINEL = 0xfbb67fda52d4bfb8bf;\n\n    /// @dev The storage layout is given by:\n    /// ```\n    ///     mstore(0x04, _ENUMERABLE_ADDRESS_SET_SLOT_SEED)\n    ///     mstore(0x00, set.slot)\n    ///     let rootSlot := keccak256(0x00, 0x24)\n    ///     mstore(0x20, rootSlot)\n    ///     mstore(0x00, shr(96, shl(96, value)))\n    ///     let positionSlot := keccak256(0x00, 0x40)\n    ///     let valueSlot := add(rootSlot, sload(positionSlot))\n    ///     let valueInStorage := shr(96, sload(valueSlot))\n    ///     let lazyLength := shr(160, shl(160, sload(rootSlot)))\n    /// ```\n    uint256 private constant _ENUMERABLE_ADDRESS_SET_SLOT_SEED = 0x978aab92;\n\n    /// @dev The storage layout is given by:\n    /// ```\n    ///     mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)\n    ///     mstore(0x00, set.slot)\n    ///     let rootSlot := keccak256(0x00, 0x24)\n    ///     mstore(0x20, rootSlot)\n    ///     mstore(0x00, value)\n    ///     let positionSlot := keccak256(0x00, 0x40)\n    ///     let valueSlot := add(rootSlot, sload(positionSlot))\n    ///     let valueInStorage := sload(valueSlot)\n    ///     let lazyLength := sload(not(rootSlot))\n    /// ```\n    uint256 private constant _ENUMERABLE_WORD_SET_SLOT_SEED = 0x18fb5864;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                          STRUCTS                           */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev An enumerable address set in storage.\n    struct AddressSet {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable bytes32 set in storage.\n    struct Bytes32Set {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable uint256 set in storage.\n    struct Uint256Set {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable int256 set in storage.\n    struct Int256Set {\n        uint256 _spacer;\n    }\n\n    /// @dev An enumerable uint8 set in storage. Useful for enums.\n    struct Uint8Set {\n        uint256 data;\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     GETTERS / SETTERS                      */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of elements in the set.\n    function length(AddressSet storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := shr(1, n)\n            for {} iszero(or(iszero(shr(96, rootPacked)), n)) {} {\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Bytes32Set storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(not(rootSlot))\n            result := shr(1, n)\n            for {} iszero(n) {} {\n                result := 0\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Uint256Set storage set) internal view returns (uint256 result) {\n        result = length(_toBytes32Set(set));\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Int256Set storage set) internal view returns (uint256 result) {\n        result = length(_toBytes32Set(set));\n    }\n\n    /// @dev Returns the number of elements in the set.\n    function length(Uint8Set storage set) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let packed := sload(set.slot) } packed { result := add(1, result) } {\n                packed := xor(packed, and(packed, add(1, not(packed))))\n            }\n        }\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(AddressSet storage set, address value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for {} 1 {} {\n                if iszero(shr(160, shl(160, rootPacked))) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for {} 1 {} {\n                if iszero(sload(not(rootSlot))) {\n                    result := 1\n                    if eq(sload(rootSlot), value) { break }\n                    if eq(sload(add(rootSlot, 1)), value) { break }\n                    if eq(sload(add(rootSlot, 2)), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Uint256Set storage set, uint256 value) internal view returns (bool result) {\n        result = contains(_toBytes32Set(set), bytes32(value));\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Int256Set storage set, int256 value) internal view returns (bool result) {\n        result = contains(_toBytes32Set(set), bytes32(uint256(value)));\n    }\n\n    /// @dev Returns whether `value` is in the set.\n    function contains(Uint8Set storage set, uint8 value) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(1, shr(and(0xff, value), sload(set.slot)))\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := shr(96, rootPacked)\n                    if iszero(v0) {\n                        sstore(rootSlot, shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := shr(96, sload(add(rootSlot, 1)))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := shr(96, sload(add(rootSlot, 2)))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    rootPacked := or(rootPacked, 7)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    result := 1\n                    sstore(p, add(1, n))\n                    if iszero(n) {\n                        sstore(rootSlot, or(3, shl(96, value)))\n                        break\n                    }\n                    sstore(add(rootSlot, n), shl(96, value))\n                    sstore(rootSlot, add(2, rootPacked))\n                    break\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := sload(rootSlot)\n                    if iszero(v0) {\n                        sstore(rootSlot, value)\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := sload(add(rootSlot, 1))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := sload(add(rootSlot, 2))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    sstore(add(rootSlot, n), value)\n                    sstore(p, add(1, n))\n                    sstore(not(rootSlot), or(1, shl(1, add(1, n))))\n                    result := 1\n                    break\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Uint256Set storage set, uint256 value) internal returns (bool result) {\n        result = add(_toBytes32Set(set), bytes32(value));\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Int256Set storage set, int256 value) internal returns (bool result) {\n        result = add(_toBytes32Set(set), bytes32(uint256(value)));\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    function add(Uint8Set storage set, uint8 value) internal returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(set.slot)\n            let mask := shl(and(0xff, value), 1)\n            sstore(set.slot, or(result, mask))\n            result := iszero(and(result, mask))\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.\n    function add(AddressSet storage set, address value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) {\n            if (length(set) > cap) revert ExceedsCapacity();\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.\n    function add(Bytes32Set storage set, bytes32 value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) {\n            if (length(set) > cap) revert ExceedsCapacity();\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.\n    function add(Uint256Set storage set, uint256 value, uint256 cap)\n        internal\n        returns (bool result)\n    {\n        if (result = add(set, value)) {\n            if (length(set) > cap) revert ExceedsCapacity();\n        }\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.\n    function add(Int256Set storage set, int256 value, uint256 cap) internal returns (bool result) {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }\n\n    /// @dev Adds `value` to the set. Returns whether `value` was not in the set.\n    /// Reverts if the set grows bigger than the custom on-the-fly capacity `cap`.\n    function add(Uint8Set storage set, uint8 value, uint256 cap) internal returns (bool result) {\n        if (result = add(set, value)) if (length(set) > cap) revert ExceedsCapacity();\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := shr(96, sload(add(rootSlot, n)))\n                    sstore(add(rootSlot, sub(position, 1)), shl(96, lastValue))\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(rootSlot, or(shl(96, shr(96, sload(rootSlot))), or(shl(1, n), 1)))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(sload(rootSlot), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 1)), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 2)), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := sload(add(rootSlot, n))\n                    sstore(add(rootSlot, sub(position, 1)), lastValue)\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(not(rootSlot), or(shl(1, n), 1))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Uint256Set storage set, uint256 value) internal returns (bool result) {\n        result = remove(_toBytes32Set(set), bytes32(value));\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Int256Set storage set, int256 value) internal returns (bool result) {\n        result = remove(_toBytes32Set(set), bytes32(uint256(value)));\n    }\n\n    /// @dev Removes `value` from the set. Returns whether `value` was in the set.\n    function remove(Uint8Set storage set, uint8 value) internal returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(set.slot)\n            let mask := shl(and(0xff, value), 1)\n            sstore(set.slot, and(result, not(mask)))\n            result := iszero(iszero(and(result, mask)))\n        }\n    }\n\n    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.\n    function update(AddressSet storage set, address value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }\n\n    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.\n    function update(Bytes32Set storage set, bytes32 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }\n\n    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.\n    function update(Uint256Set storage set, uint256 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }\n\n    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.\n    function update(Int256Set storage set, int256 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }\n\n    /// @dev Shorthand for `isAdd ? set.add(value, cap) : set.remove(value)`.\n    function update(Uint8Set storage set, uint8 value, bool isAdd, uint256 cap)\n        internal\n        returns (bool)\n    {\n        return isAdd ? add(set, value, cap) : remove(set, value);\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(AddressSet storage set) internal view returns (address[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            let v := shr(96, rootPacked)\n            mstore(o, mul(v, iszero(eq(v, zs))))\n            for {} 1 {} {\n                if iszero(n) {\n                    if v {\n                        n := 1\n                        v := shr(96, sload(add(rootSlot, n)))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := shr(96, sload(add(rootSlot, n)))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 1 } lt(i, n) { i := add(i, 1) } {\n                    v := shr(96, sload(add(rootSlot, i)))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let n := sload(not(rootSlot))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            for {} 1 {} {\n                if iszero(n) {\n                    let v := sload(rootSlot)\n                    if v {\n                        n := 1\n                        mstore(o, mul(v, iszero(eq(v, zs))))\n                        v := sload(add(rootSlot, n))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := sload(add(rootSlot, n))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 0 } lt(i, n) { i := add(i, 1) } {\n                    let v := sload(add(rootSlot, i))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(Uint256Set storage set) internal view returns (uint256[] memory result) {\n        result = _toUints(values(_toBytes32Set(set)));\n    }\n\n    /// @dev Returns all of the values in the set.\n    /// Note: This can consume more gas than the block gas limit for large sets.\n    function values(Int256Set storage set) internal view returns (int256[] memory result) {\n        result = _toInts(values(_toBytes32Set(set)));\n    }\n\n    /// @dev Returns all of the values in the set.\n    function values(Uint8Set storage set) internal view returns (uint8[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let ptr := add(result, 0x20)\n            let o := 0\n            for { let packed := sload(set.slot) } packed {} {\n                if iszero(and(packed, 0xffff)) {\n                    o := add(o, 16)\n                    packed := shr(16, packed)\n                    continue\n                }\n                mstore(ptr, o)\n                ptr := add(ptr, shl(5, and(packed, 1)))\n                o := add(o, 1)\n                packed := shr(1, packed)\n            }\n            mstore(result, shr(5, sub(ptr, add(result, 0x20))))\n            mstore(0x40, ptr)\n        }\n    }\n\n    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.\n    function at(AddressSet storage set, uint256 i) internal view returns (address result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(96, sload(add(rootSlot, i)))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }\n\n    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.\n    function at(Bytes32Set storage set, uint256 i) internal view returns (bytes32 result) {\n        result = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(add(result, i))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }\n\n    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.\n    function at(Uint256Set storage set, uint256 i) internal view returns (uint256 result) {\n        result = uint256(at(_toBytes32Set(set), i));\n    }\n\n    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.\n    function at(Int256Set storage set, uint256 i) internal view returns (int256 result) {\n        result = int256(uint256(at(_toBytes32Set(set), i)));\n    }\n\n    /// @dev Returns the element at index `i` in the set. Reverts if `i` is out-of-bounds.\n    function at(Uint8Set storage set, uint256 i) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(set.slot)\n            for {} 1 {\n                mstore(0x00, 0x4e23d035) // `IndexOutOfBounds()`.\n                revert(0x1c, 0x04)\n            } {\n                if iszero(lt(i, 256)) { continue }\n                for { let j := 0 } iszero(eq(i, j)) {} {\n                    packed := xor(packed, and(packed, add(1, not(packed))))\n                    j := add(j, 1)\n                }\n                if iszero(packed) { continue }\n                break\n            }\n            // Find first set subroutine, optimized for smaller bytecode size.\n            let x := and(packed, add(1, not(packed)))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            result := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }\n\n    /// @dev Returns the index of `value`. Returns `NOT_FOUND` if the value does not exist.\n    function indexOf(AddressSet storage set, address value) internal view returns (uint256 result) {\n        result = NOT_FOUND;\n        if (uint160(value) == _ZERO_SENTINEL) return result;\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(value) { value := _ZERO_SENTINEL }\n            result := not(0)\n            let rootPacked := sload(rootSlot)\n            for {} 1 {} {\n                if iszero(shr(160, shl(160, rootPacked))) {\n                    if eq(shr(96, rootPacked), value) {\n                        result := 0\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) {\n                        result := 1\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) {\n                        result := 2\n                        break\n                    }\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := sub(sload(keccak256(0x00, 0x40)), 1)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the index of `value`. Returns `NOT_FOUND` if the value does not exist.\n    function indexOf(Bytes32Set storage set, bytes32 value) internal view returns (uint256 result) {\n        result = NOT_FOUND;\n        if (uint256(value) == _ZERO_SENTINEL) return result;\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for {} 1 {} {\n                if iszero(sload(not(rootSlot))) {\n                    if eq(sload(rootSlot), value) {\n                        result := 0\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 1)), value) {\n                        result := 1\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 2)), value) {\n                        result := 2\n                        break\n                    }\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := sub(sload(keccak256(0x00, 0x40)), 1)\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the index of `value`. Returns `NOT_FOUND` if the value does not exist.\n    function indexOf(Uint256Set storage set, uint256 i) internal view returns (uint256 result) {\n        result = indexOf(_toBytes32Set(set), bytes32(i));\n    }\n\n    /// @dev Returns the index of `value`. Returns `NOT_FOUND` if the value does not exist.\n    function indexOf(Int256Set storage set, int256 i) internal view returns (uint256 result) {\n        result = indexOf(_toBytes32Set(set), bytes32(uint256(i)));\n    }\n\n    /// @dev Returns the index of `value`. Returns `NOT_FOUND` if the value does not exist.\n    function indexOf(Uint8Set storage set, uint8 value) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0)\n            let packed := sload(set.slot)\n            let m := shl(and(0xff, value), 1)\n            if and(packed, m) {\n                result := 0\n                for { let p := and(packed, sub(m, 1)) } p {} {\n                    p := xor(p, and(p, add(1, not(p))))\n                    result := add(result, 1)\n                }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                      PRIVATE HELPERS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the root slot.\n    function _rootSlot(AddressSet storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_ADDRESS_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }\n\n    /// @dev Returns the root slot.\n    function _rootSlot(Bytes32Set storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }\n\n    /// @dev Casts to a Bytes32Set.\n    function _toBytes32Set(Uint256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }\n\n    /// @dev Casts to a Bytes32Set.\n    function _toBytes32Set(Int256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }\n\n    /// @dev Casts to a uint256 array.\n    function _toUints(bytes32[] memory a) private pure returns (uint256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }\n\n    /// @dev Casts to a int256 array.\n    function _toInts(bytes32[] memory a) private pure returns (int256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }\n}\n"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@openzeppelin/=lib/openzeppelin-contracts/","solady/=lib/solady/src/","ds-test/=lib/permit2/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/","forge-gas-snapshot/=lib/permit2/lib/forge-gas-snapshot/src/","forge-std/=lib/forge-std/src/","openzeppelin-contracts/=lib/openzeppelin-contracts/","permit2/=lib/permit2/","solmate/=lib/permit2/lib/solmate/"],"optimizer":{"enabled":true,"runs":10000000},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":false},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode.object","evm.bytecode.sourceMap","evm.bytecode.linkReferences","evm.deployedBytecode.object","evm.deployedBytecode.sourceMap","evm.deployedBytecode.linkReferences","evm.deployedBytecode.immutableReferences","evm.methodIdentifiers","metadata","storageLayout"]}},"evmVersion":"cancun","viaIR":false,"libraries":{}}}
